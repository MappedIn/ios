// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.2.4 (swiftlang-1103.0.32.9 clang-1103.0.32.53)
// swift-module-flags: -target x86_64-apple-ios13.1-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name MappedIn
import CoreLocation
import Foundation
import Mapbox
@_exported import MappedIn
import MappedinVenueFormat
import Swift
import UIKit
@_hasMissingDesignatedInitializers open class MiCategory {
  final public let id: Swift.String
  final public let name: Swift.String
  final public let picture: MappedIn.MiPicture?
  public init(id: Swift.String, name: Swift.String, picture: MappedIn.MiPicture? = nil)
  public var locations: [MappedIn.MiLocation]
  @objc deinit
}
@_hasMissingDesignatedInitializers open class MiLevelManager {
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers open class MiMapView : Mapbox.MGLMapView, UIKit.UIGestureRecognizerDelegate {
  public var venue: MappedIn.MiVenue? {
    get
  }
  public var levelLayersManager: MappedIn.MiLayerManager? {
    get
  }
  public var polygonStyleManager: MappedIn.MiPolygonStyleManager? {
    get
  }
  public var positionManager: MappedIn.MiPositionManager? {
    get
  }
  public var cameraManager: MappedIn.MiCameraManager? {
    get
  }
  public var pathManager: MappedIn.MiPathManager? {
    get
  }
  public var levelManager: MappedIn.MiLevelManager? {
    get
  }
  public var levels: [MappedIn.MiLevel] {
    get
  }
  public var currentLevel: MappedIn.MiLevel? {
    get
  }
  weak public var miDelegate: MappedIn.MiMapViewDelegate?
  @objc override dynamic public init(frame: CoreGraphics.CGRect, styleURL: Foundation.URL?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc override dynamic public var delegate: Mapbox.MGLMapViewDelegate? {
    @objc get
    @objc set(newDelegate)
  }
  public func loadMap(venue: MappedIn.MiVenue, defaultLevel: MappedIn.MiLevel? = nil)
  @objc public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  public func setLevel(level: MappedIn.MiLevel)
  public func incrementLevel()
  public func decrementLevel()
  public func canIncrementLevel() -> Swift.Bool
  public func canDecrementLevel() -> Swift.Bool
  public func clearAllPolygonStyles()
  public func createNavigationPath<VenueNavigatable>(from: VenueNavigatable, to: VenueNavigatable, accessible: Swift.Bool = false, pathWidth: Swift.Double = 10.0, pathColor: UIKit.UIColor = UIColor.white) -> (MappedIn.MiDirections, MappedIn.MiPath)? where VenueNavigatable : MappedIn.MiNavigable
  public func addPath(path: MappedIn.MiPath)
  public func removePath(path: MappedIn.MiPath)
  public func removeAllPaths(level: MappedIn.MiLevel? = nil)
  public func clearPolygonStyle(id: Swift.String)
  public func setPolygonColor(id: Swift.String, styleProperties: MappedIn.MiHighlightProperties)
  public func setPolygonOutline(id: Swift.String, styleProperties: MappedIn.MiOutlineProperties)
  public func focusOn(focusable: MappedIn.MiFocusable, heading: Swift.Double? = nil, tilt: Swift.Double? = nil, padding: Swift.Double = 0, over: Swift.Double)
  public func focusOn(focusables: [MappedIn.MiFocusable], heading: Swift.Double? = nil, tilt: Swift.Double? = nil, padding: Swift.Double = 0, over: Swift.Double)
  public func focusOnCurrentLevel(heading: Swift.Double? = nil, tilt: Swift.Double? = nil, padding: Swift.Double = 0, over: Swift.Double = 0)
  @objc override dynamic public var userLocation: Mapbox.MGLUserLocation? {
    @objc get
  }
  public func startTrackingUserPosition(useDefaultLocationEngine: Swift.Bool)
  public func updateUserPosition(point: CoreLocation.CLLocationCoordinate2D, level: Swift.Int? = nil)
  public func show3DLayers()
  public func hide3DLayers()
  public func spacesInView() -> [MappedIn.MiSpace]
  public func changeBackgroundColor(color: Foundation.NSExpression)
  public func changeBackgroundColor(color: UIKit.UIColor)
  public func addLocationSmartLabels(level: MappedIn.MiLevel)
  public func displayOverlays(overlays: [MappedIn.MiOverlay])
  public func removeAllOverlays(level: MappedIn.MiLevel? = nil)
  public func getOverlays(level: MappedIn.MiLevel? = nil) -> [MappedIn.MiOverlay]
  public func removeOverlays(overlays: [MappedIn.MiOverlay])
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
}
@_hasMissingDesignatedInitializers open class MiDirections {
  public var path: [MappedIn.MiNode]
  public var instructions: [MappedIn.MiInstruction]
  final public let distance: Swift.Double
  @objc deinit
}
@_hasMissingDesignatedInitializers open class MiFocusPoint {
  @objc deinit
}
@_hasMissingDesignatedInitializers open class MiLayerManager {
  final public let id: Swift.String
  public var smartLabelManager: MappedIn.MiSmartLabelManager?
  public var overlayManager: MappedIn.MiOverlayManager?
  public func setStyles()
  public func enableLayer(layer: Swift.Int, enable: Swift.Bool)
  @objc deinit
}
public enum MiGestureType {
  case PINCH
  case PAN
  public static func == (a: MappedIn.MiGestureType, b: MappedIn.MiGestureType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers open class MiNode : MappedIn.MiNavigable, Swift.Hashable, MappedIn.MiFocusable {
  public var navigatableNodes: [MappedIn.MiNode] {
    get
  }
  final public let id: Swift.String
  final public let externalId: Swift.String?
  final public let weight: Swift.Double
  final public let multiplier: Swift.Double
  final public let accessible: Swift.Bool
  public var pathLinks: [Swift.String] {
    get
  }
  public var lon: Swift.Double {
    get
  }
  public var lat: Swift.Double {
    get
  }
  public var z: Swift.Double {
    get
  }
  final public let levelId: Swift.String
  public var level: MappedIn.MiLevel? {
    get
  }
  public var spaces: [MappedIn.MiSpace] {
    get
  }
  public var locations: [MappedIn.MiLocation] {
    get
  }
  public func getPoints() -> [MappedIn.MiFocusPoint]
  public static func == (lhs: MappedIn.MiNode, rhs: MappedIn.MiNode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  open var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers open class MiCameraManager {
  public func setTilt(tilt: Swift.Double, over: Swift.Double)
  public func disableTilt(over: Swift.Double = 1)
  public func focusOn(focusables: [MappedIn.MiFocusable], heading: Swift.Double? = nil, tilt: Swift.Double? = nil, padding: Swift.Double = 0, over: Swift.Double)
  public func focusOn(focusable: MappedIn.MiFocusable, heading: Swift.Double? = nil, tilt: Swift.Double? = nil, padding: Swift.Double = 0, over: Swift.Double = 0)
  @objc deinit
}
@_hasMissingDesignatedInitializers open class MiPolygonOutlineManager : MappedIn.MiBasePolygonStyleManager {
  @objc deinit
}
public struct MiPicture : Swift.Codable {
  public let original: Swift.String?
  public let xxsmall: Swift.String?
  public let xsmall: Swift.String?
  public let small: Swift.String?
  public let medium: Swift.String?
  public let large: Swift.String?
  public let xlarge: Swift.String?
  public let xxlarge: Swift.String?
  public let dimension66x66: Swift.String?
  public let dimension140x140: Swift.String?
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers open class MiPositionManager {
  public func startTrackingUserPosition(useDefaultLocationEngine: Swift.Bool)
  public func updateUserPosition(point: CoreLocation.CLLocationCoordinate2D, level: Swift.Int?)
  @objc deinit
}
public enum MIGetVenueResultCode {
  case SUCCESS
  case SUCCESS_CACHED
  case FAILED
  case FAILED_TO_CONFIGURE_MVF
  case FAILED_TO_GET_MANIFEST
  case FAILED_TO_DOWNLOAD
  case FAILED_TO_PARSE_FILES
  public static func == (a: MappedIn.MIGetVenueResultCode, b: MappedIn.MIGetVenueResultCode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public typealias DataCompletionHandler = (Foundation.Data?, Foundation.URLResponse?, Swift.Error?) -> Swift.Void
public enum HttpError : Swift.Error {
  case requestError(Swift.Error)
  case missingData
  case requestTimeout
  case invalidJSON(Swift.Error)
  case invalidJSONSchemea
  case httpErrorCode(Swift.Int)
  public var localizedDescription: Swift.String {
    get
  }
}
public struct MiAnalytics {
  public static var deviceData: [Swift.String : Any]
  public static func updateSessionId()
  public static func enteredApp(completionHandler: MappedIn.DataCompletionHandler? = nil)
  public static func exitedApp(completionHandler: MappedIn.DataCompletionHandler? = nil)
  public static func selectedVenue(_ venue: Swift.String, completionHandler: MappedIn.DataCompletionHandler? = nil)
  public static func selectedLocation(_ location: MappedIn.MiLocation, _ venue: Swift.String?, completionHandler: MappedIn.DataCompletionHandler? = nil)
  public static func selectedCategory(_ venue: Swift.String, _ categoryId: Swift.String, completionHandler: MappedIn.DataCompletionHandler? = nil)
  public static func startedWayfindTo(_ location: MappedIn.MiLocation, _ venue: Swift.String?, completionHandler: MappedIn.DataCompletionHandler? = nil) -> MappedIn.MiAnalytics.MiWayfind
  @_hasMissingDesignatedInitializers open class MiWayfind {
    public func successful(completionHandler: MappedIn.DataCompletionHandler? = nil)
    @objc deinit
  }
}
open class MiStyleProperties {
  public init(color: UIKit.UIColor, opacity: Swift.Double)
  @objc deinit
}
@_hasMissingDesignatedInitializers open class MiSmartLabelManager {
  @objc deinit
}
@_hasMissingDesignatedInitializers open class MiConnection {
  final public let originNodeId: Swift.String
  public var destinationNodeIds: [Swift.String] {
    get
  }
  final public let name: Swift.String
  final public let type: Swift.String?
  final public let accessible: Swift.Bool
  final public let weight: Swift.Double
  final public let multiplier: Swift.Double
  @objc deinit
}
@_hasMissingDesignatedInitializers open class MiOverlayManager {
  public func getOverlayFeatures() -> [Mapbox.MGLPointFeature]
  public func displayOverlays(overlays: [MappedIn.MiOverlay])
  public func removeOverlays(overlays: [MappedIn.MiOverlay])
  public func clear()
  public func addLayer()
  public func removeLayer()
  @objc deinit
}
open class MiOutlineProperties : MappedIn.MiStyleProperties {
  public init(color: UIKit.UIColor, width: Swift.Double, opacity: Swift.Double)
  @objc deinit
  override public init(color: UIKit.UIColor, opacity: Swift.Double)
}
@_hasMissingDesignatedInitializers open class MiPathSegment {
  public var level: MappedIn.MiLevel? {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers open class MiLocation : MappedIn.BaseObject, MappedIn.MiNavigable {
  final public let name: Swift.String
  final public let externalId: Swift.String?
  public var navigatableNodes: [MappedIn.MiNode]
  public var spaces: [MappedIn.MiSpace]
  public var categories: [MappedIn.MiCategory]
  final public let logo: MappedIn.MiPicture?
  final public let picture: MappedIn.MiPicture?
  @objc deinit
}
@_inheritsConvenienceInitializers open class MiHighlightProperties : MappedIn.MiStyleProperties {
  @objc deinit
  override public init(color: UIKit.UIColor, opacity: Swift.Double)
}
@_hasMissingDesignatedInitializers open class MiPolygonStyleManager {
  public func setPolygonColor(id: Swift.String, styleProperties: MappedIn.MiHighlightProperties)
  public func setPolygonOutline(id: Swift.String, styleProperties: MappedIn.MiOutlineProperties)
  public func clearAllPolygonStyles()
  public func clearPolygonStyle(id: Swift.String)
  @objc deinit
}
open class MiOverlay {
  final public let id: Swift.String
  final public let coordinates: CoreLocation.CLLocationCoordinate2D
  final public let feature: Mapbox.MGLPointFeature
  final public let image: UIKit.UIImage
  final public let level: MappedIn.MiLevel
  public init(coordinates: CoreLocation.CLLocationCoordinate2D, level: MappedIn.MiLevel, image: UIKit.UIImage)
  convenience public init(coordinates: CoreLocation.CLLocationCoordinate2D, level: MappedIn.MiLevel, view: UIKit.UIView)
  @objc deinit
}
public class MappedIn {
  public init()
  public init(mappedinKey: Swift.String, mappedinSecret: Swift.String, mappedinEndpoint: Swift.String? = nil)
  public func getVenue(venueSlug: Swift.String, enableOfflineSupport: Swift.Bool = true, completionHandler: @escaping (MappedIn.MIGetVenueResultCode, MappedIn.MiVenue?) -> (Swift.Void))
  public func getVenues(completionHandler: @escaping (MappedIn.MIGetVenueResultCode, [(Swift.String, Swift.String)]) -> (Swift.Void))
  @objc deinit
}
@_hasMissingDesignatedInitializers open class MiPolygonHighlightManager : MappedIn.MiBasePolygonStyleManager {
  @objc deinit
}
public protocol MiMapViewDelegate : AnyObject {
  func onTapNothing()
  func didTapSpace(space: MappedIn.MiSpace) -> Swift.Bool
  func onTapCoordinates(point: CoreLocation.CLLocationCoordinate2D)
  func didTapOverlay(overlay: MappedIn.MiOverlay) -> Swift.Bool
  func onLevelChange(level: MappedIn.MiLevel)
  func onManipulateCamera(gesture: MappedIn.MiGestureType)
  func onMapLoaded(status: MappedIn.MiMapStatus)
}
@_hasMissingDesignatedInitializers open class MiSmartLabel {
  final public let level: MappedIn.MiLevel
  final public let text: Swift.String
  final public let point: Mapbox.MGLPointFeature
  final public let id: Swift.String
  @objc deinit
}
public protocol MiFocusable {
  func getPoints() -> [MappedIn.MiFocusPoint]
}
@_hasMissingDesignatedInitializers open class MiLevel : MappedIn.BaseObject, Swift.Hashable, MappedIn.MiFocusable {
  final public let name: Swift.String
  final public let abbreviation: Swift.String
  final public let elevation: Swift.Int
  public var nodes: [Swift.String : MappedIn.MiNode]
  final public let building: Swift.String
  public var connections: [Swift.String : MappedIn.MiConnection] {
    get
  }
  public var locations: [Swift.String : MappedIn.MiLocation] {
    get
  }
  public var spaces: [Swift.String : MappedIn.MiSpace] {
    get
  }
  public var smartLabels: [MappedIn.MiSmartLabel] {
    get
  }
  public func getPoints() -> [MappedIn.MiFocusPoint]
  public static func == (lhs: MappedIn.MiLevel, rhs: MappedIn.MiLevel) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  open var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers open class MiVenue {
  final public let slug: Swift.String
  final public let name: Swift.String
  final public let levels: [MappedIn.MiLevel]
  final public let locations: [MappedIn.MiLocation]
  final public let spaces: [MappedIn.MiSpace]
  final public let categories: [MappedIn.MiCategory]
  @objc deinit
}
@_hasMissingDesignatedInitializers open class BaseObject {
  final public let id: Swift.String
  @objc deinit
}
@_hasMissingDesignatedInitializers open class MiPathManager {
  @objc deinit
}
public protocol MiNavigable {
  var navigatableNodes: [MappedIn.MiNode] { get }
}
extension MiNavigable {
  public var isNavigatable: Swift.Bool {
    get
  }
}
extension MiNavigable {
  public func directions<VenueNavigatable>(activeVenue: MappedIn.MiVenue, to destination: VenueNavigatable, accessible: Swift.Bool = false) -> MappedIn.MiDirections? where VenueNavigatable : MappedIn.MiNavigable
  public func directions<VenueNavigatable>(activeVenue: MappedIn.MiVenue, from origin: VenueNavigatable, accessible: Swift.Bool = false) -> MappedIn.MiDirections? where VenueNavigatable : MappedIn.MiNavigable
}
@_hasMissingDesignatedInitializers open class MiSpace : MappedIn.BaseObject, MappedIn.MiNavigable, Swift.Equatable, MappedIn.MiFocusable {
  public var navigatableNodes: [MappedIn.MiNode] {
    get
  }
  public var level: MappedIn.MiLevel? {
    get
  }
  final public let levelId: Swift.String
  final public let parent: Swift.String?
  final public let externalId: Swift.String?
  final public let layer: Swift.String?
  final public let color: Swift.String?
  final public let height: Swift.Double?
  final public let altitude: Swift.Double?
  public var feature: Mapbox.MGLShape? {
    get
  }
  public var entrances: [MappedIn.MiNode] {
    get
  }
  public var pointNode: MappedIn.MiNode? {
    get
  }
  public var locations: [MappedIn.MiLocation] {
    get
  }
  public func getPoints() -> [MappedIn.MiFocusPoint]
  public static func == (lhs: MappedIn.MiSpace, rhs: MappedIn.MiSpace) -> Swift.Bool
  @objc deinit
}
public typealias MiAction = MappedIn.DirectionsInstructionAction
public struct Departure : MappedIn.MiAction {
}
public struct Arrival : MappedIn.MiAction {
}
public struct Turn : MappedIn.MiAction {
  public enum Bearing {
    case left
    case slightLeft
    case straight
    case slightRight
    case right
    public static func == (a: MappedIn.Turn.Bearing, b: MappedIn.Turn.Bearing) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let relativeBearing: MappedIn.Turn.Bearing
}
public struct TakeConnection : MappedIn.MiAction {
  public let fromLevel: MappedIn.MiLevel
  public let toLevel: MappedIn.MiLevel
  public let connection: MappedIn.MiConnection
}
public struct ExitConnection : MappedIn.MiAction {
  public let fromLevel: MappedIn.MiLevel
  public let toLevel: MappedIn.MiLevel
  public let connection: MappedIn.MiConnection
}
public protocol DirectionsInstructionAction {
}
@_hasMissingDesignatedInitializers open class MiBasePolygonStyleManager {
  public func stylePolygon(id: Swift.String, styleProperties: MappedIn.MiStyleProperties)
  public func clearAllPolygonStyles()
  public func clearPolygonStyle(id: Swift.String)
  @objc deinit
}
public struct MiInstruction {
  public let node: MappedIn.MiNode
  public let action: MappedIn.MiAction
  public let atLocation: MappedIn.MiLocation?
  public var description: Swift.String {
    get
  }
}
public enum MiMapStatus {
  case loaded
  case error
  public static func == (a: MappedIn.MiMapStatus, b: MappedIn.MiMapStatus) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers open class MiPath : MappedIn.MiFocusable {
  public var segments: [MappedIn.MiPathSegment] {
    get
  }
  public init(pathPoints: [CoreLocation.CLLocationCoordinate2D], pathWidth: Swift.Double, pathColor: UIKit.UIColor, level: MappedIn.MiLevel? = nil)
  public init(path: [MappedIn.MiNode], pathWidth: Swift.Double, pathColor: UIKit.UIColor)
  public func getPoints() -> [MappedIn.MiFocusPoint]
  @objc deinit
}
public struct MiBackgroundStyle {
  public var color: Foundation.NSExpression
}
public struct MiLevelStyle {
  public var fillColor: Foundation.NSExpression
}
public struct MiSpaceStyle {
  public var fillColor: Foundation.NSExpression
  public var fillColorTransition: Mapbox.MGLTransition
  public var fillOpacityTransition: Mapbox.MGLTransition
}
public struct MiSpaceWallStyle {
  public var fillOpacityTransition: Mapbox.MGLTransition
  public var lineWidth: Foundation.NSExpression
  public var lineColor: Foundation.NSExpression
}
public struct MiObstructionStyle {
}
public struct MiObstructionOutlineStyle {
}
public struct MiSpaceOutlineWallStyle {
}
public struct Mi3DStyle {
}
public struct MiLabelsStyle {
}
public struct MiPathStyle {
}
public struct MiLayerStyles {
  public var backgroundStyle: MappedIn.MiBackgroundStyle
  public var levelStyle: MappedIn.MiLevelStyle
  public var spaceStyle: MappedIn.MiSpaceStyle
  public var spaceWallStyle: MappedIn.MiSpaceWallStyle
  public var spaceOutlineStyle: MappedIn.MiSpaceOutlineWallStyle
  public var obstructionStyle: MappedIn.MiObstructionStyle
  public var obstructionOutlineStyle: MappedIn.MiObstructionOutlineStyle
  public var aestheticStyle: MappedIn.MiObstructionStyle
  public var labelsStyle: MappedIn.MiLabelsStyle
  public var level3DStyle: MappedIn.Mi3DStyle
  public var space3DStyle: MappedIn.Mi3DStyle
  public var obstruction3DStyle: MappedIn.Mi3DStyle
  public var aesthetic3DStyle: MappedIn.Mi3DStyle
  public var pathStyle: MappedIn.MiPathStyle
  public init()
}
extension MappedIn.MiGestureType : Swift.Equatable {}
extension MappedIn.MiGestureType : Swift.Hashable {}
extension MappedIn.MIGetVenueResultCode : Swift.Equatable {}
extension MappedIn.MIGetVenueResultCode : Swift.Hashable {}
extension MappedIn.Turn.Bearing : Swift.Equatable {}
extension MappedIn.Turn.Bearing : Swift.Hashable {}
extension MappedIn.MiMapStatus : Swift.Equatable {}
extension MappedIn.MiMapStatus : Swift.Hashable {}
