// Thank you for trying out the Mappedin iOS SDK. This is a short walkthrough that will
// get you up in running with the SDK as quickly as possible.
//
// This example is designed with all the source in a single file, this is not nessarly
// good form but was done so you as a Developer can understand the sum of the SDK without
// having to navigate around the source.
//

// First thing is first, add the Mappedin framework to your project such that it
// can be linked into the source.
import Mappedin

// Secondly, a `Service` _must_ be defined. The role of a `Service` is to tell our
// API what keys to use, and what data types you have defined for use in the SDK.
struct Service: Mappedin.Service {
    // First you must specify if you are using a custom `Venue` type, This is normal
    // and required for almost all of our customers.
    typealias VenueType = Venue
    let venueType = Venue.self

    // Now the Keys and other secret data are pinned to your app here
    // this will be used when doing any API requests to the Mappedin servers
    //
    // if these values are not set with the keys provided by Mappedin via
    // our agents. Please contact us to get started.
    let apiKey = ""
    let apiSecret = ""
    let dataKey = ""

    // not needed, just done to make sure you set the abover balues.
    init() {
        assert(apiKey != "", """
            It looks like you are using the SDK without an api key. \
            Please go to the `Service` sturcture and specifiy a key \
            secret and a data key. If you do not know this information \
            please contact your Mappedin to get access to our API.
            """
        )
    }

}

// The 1st class you will need to define is a `Venue` class. A `Venue` holds one or more
// maps and all the associated data that is needed for searching / direction wayfinding.
//
// The Venue will include custom deserialization that is supplied by Mappedin. This code
// is ridged and is best if you avoid touching it.
class Venue: Mappedin.Venue {
    // custom types can be added by our backend servers
    var typedLocations = [TypedLocation]()
    // an example Custom type, generated by our API servers
    class TypedLocation: Mappedin.Location {
        var externalId: String = ""
        required init(from buffer: inout BinaryDecoder) throws {
            try super.init(from: &buffer)
            self.externalId = try buffer.pullValue()
        }
    }
    
    // If you are including custom types you _must_ include a custom deserilization
    // initializer. This is supplied by Mappedin, and should not be modified.
    required init(inflate venueListing: VenueListing,
                  with buffer: inout BinaryDecoder) throws
    {
        try super.init(inflate: venueListing, with: &buffer)
        self.typedLocations = try buffer.pullValue()

        // location's contain a `venue` field that must be linked. with a reverse
        // link. This is done for both your convince making other APIs simpler
        self.typedLocations.forEach { $0.venue = self }
        
        // The location field contains all the possible locations, we can't magically
        // populate this array for you, so you must do it for us.
        self.locations = self.typedLocations.map{ $0 as Location }
    }
}


// To start, like any application you are going to need an AppDelegate delegate
import UIKit

// the service doesn't normally have any logic in it, and just acts as an entry
// point. So it is easy to leave it is a global rather then passing it around
// this will be up to how your company decides the best way to structure your
// code base is.
var service: Service? = nil

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
    var window: UIWindow?

    override init() {
        super.init()
        // this is the last tricky bit, the Service initializer requires
        // some extra swizzling on the AppDelegate in order allow our APIs
        // to get access to some internal messages that we need to do analytics
        // and background service integration.
        //
        // If your app crashes, you may see it walk through some of our SDK at the
        // bottom of the call stack. This is why.
        //
        // This must be initialized at this point, it's ugly, and I'm sorry this
        //  will be improved in the future. It can't be done before, nor after. :(
        service = Service(AppDelegate.self)
    }

}

// The API allows for multiple `Venues` to be present. This means
// if you have multiple locations you can use a single app for all
// of them.
class VenueListController: UITableViewController {
    var venues = [VenueListing]()
    @IBOutlet var table: UITableView!
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        self.loadVenues()
    }
    
    func loadVenues() {
        // This will create a listing of all the Venues that your Mappedin
        // account currently has. If you already know the name of the Venue
        // you want, you can skip this view and integrate this search into
        // the app init
        service!.getVenues()
            .onComplete { venues in
                self.venues = venues
                self.table.reloadData()
            }.onError { error in
                // try try again
                self.loadVenues()
            }
    }
    
    // tableview housekeeping, this is all UIKit logic so I will not explain it
    override func tableView(_ tableView: UITableView, numberOfRowsInSection _: Int) -> Int {
        return self.venues.count
    }
    
    override func tableView(_ tableView: UITableView, cellForRowAt: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(
            withIdentifier: "TableViewCell",
            for: cellForRowAt
        ) as! TableViewCell
        cell.name.text = venues[cellForRowAt.item].name
        return cell
    }
    
    // In a storyboard-based application, you will often want to do a little
    // preparation before navigation
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        super.prepare(for: segue, sender: sender)
        
        if segue.identifier == "ShowMap" {
            guard let cell = sender as? TableViewCell,
                  let controller = segue.destination as? MapViewController,
                  let index = tableView.indexPath(for: cell)
                  else { return }
            
            let selectedVenue = self.venues[index.row]
            controller.loadVenue(venue: selectedVenue)
        }
    }
}

// a simple class just holding the UILabel from the storyboard
class TableViewCell: UITableViewCell {
    @IBOutlet weak var name: UILabel!
}

// A class is needed to control the behavior of the MapView
class MapViewController: UIViewController  {
    @IBOutlet var mapView: MapView!
    // This is important, The Venue's will return children from many calls, all
    // of these children contain a link back to the parent, this is maintained
    // as a weak link and dropping the parent will cause the entire
    // data structure to drop
    var venue: Venue?
    
    // load a venue from the Mappedin server into this view
    func loadVenue(venue: VenueListing) {
        // This will fetch the venue from our API servers, it completes in an
        // asynchronous way. So might need some form of synchronization if
        // your logic is fancier then what is shown.
        //
        // Note: The callback `onComplete` or `OnError` will only execute on
        // the UI thread. this is done as a convince to the API users.
        service!.getVenue(venue).onComplete { venue in
            // pin the venue
            self.venue = venue

            // The venue can hold 1 to any number of maps, but to keep this simple
            // we are only going to use the first map.
            let map = self.venue!.maps.first!

            // this will choose which map you would like to show in the viewport
            self.mapView.setMap(map)

            // this will project the screen in such a way that the entire map
            // is clearly in frame.
            self.mapView.frame(map, heading: map.heading, tilt: Float.pi/4, over: 1)
        }
    }
}
