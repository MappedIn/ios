// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.2.4 (swiftlang-1103.0.32.9 clang-1103.0.32.53)
// swift-module-flags: -target x86_64-apple-ios13.1-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name MappedIn
import CoreLocation
import Foundation
import Mapbox
@_exported import MappedIn
import MappedinVenueFormat
import Swift
import UIKit
@_hasMissingDesignatedInitializers open class MiCategory {
  final public let id: Swift.String
  final public let name: Swift.String
  final public let picture: MiPicture?
  public init(id: Swift.String, name: Swift.String, picture: MiPicture? = nil)
  public var locations: [MiLocation]
  @objc deinit
}
@_hasMissingDesignatedInitializers open class MiLevelManager {
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers open class MiMapView : Mapbox.MGLMapView, UIKit.UIGestureRecognizerDelegate {
  public var venue: MiVenue? {
    get
  }
  public var levelLayersManager: MiLayerManager? {
    get
  }
  public var polygonStyleManager: MiPolygonStyleManager? {
    get
  }
  public var positionManager: MiPositionManager? {
    get
  }
  public var cameraManager: MiCameraManager? {
    get
  }
  public var pathManager: MiPathManager? {
    get
  }
  public var levelManager: MiLevelManager? {
    get
  }
  public var levels: [MiLevel] {
    get
  }
  public var currentLevel: MiLevel? {
    get
  }
  weak public var miDelegate: MiMapViewDelegate?
  @objc override dynamic public init(frame: CoreGraphics.CGRect, styleURL: Foundation.URL?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc override dynamic public var delegate: Mapbox.MGLMapViewDelegate? {
    @objc get
    @objc set(newDelegate)
  }
  public func loadMap(venue: MiVenue, defaultLevel: MiLevel? = nil)
  @objc public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  public func setLevel(level: MiLevel)
  public func incrementLevel()
  public func decrementLevel()
  public func canIncrementLevel() -> Swift.Bool
  public func canDecrementLevel() -> Swift.Bool
  public func clearAllPolygonStyles()
  public func createNavigationPath<VenueNavigatable>(from: VenueNavigatable, to: VenueNavigatable, accessible: Swift.Bool = false, pathWidth: Swift.Double = 10.0, pathColor: UIKit.UIColor = UIColor.white) -> (MiDirections, MiPath)? where VenueNavigatable : MiNavigable
  public func addPath(path: MiPath)
  public func removePath(path: MiPath)
  public func removeAllPaths(level: MiLevel? = nil)
  public func clearPolygonStyle(id: Swift.String)
  public func setPolygonColor(id: Swift.String, styleProperties: MiHighlightProperties)
  public func setPolygonOutline(id: Swift.String, styleProperties: MiOutlineProperties)
  public func focusOn(focusable: MiFocusable, heading: Swift.Double? = nil, tilt: Swift.Double? = nil, padding: Swift.Double = 0, over: Swift.Double)
  public func focusOn(focusables: [MiFocusable], heading: Swift.Double? = nil, tilt: Swift.Double? = nil, padding: Swift.Double = 0, over: Swift.Double)
  public func focusOnCurrentLevel(heading: Swift.Double? = nil, tilt: Swift.Double? = nil, padding: Swift.Double = 0, over: Swift.Double = 0)
  @objc override dynamic public var userLocation: Mapbox.MGLUserLocation? {
    @objc get
  }
  public func startTrackingUserPosition(useDefaultLocationEngine: Swift.Bool)
  public func updateUserPosition(point: CoreLocation.CLLocationCoordinate2D, level: Swift.Int? = nil)
  public func show3DLayers()
  public func hide3DLayers()
  public func spacesInView() -> [MiSpace]
  public func changeBackgroundColor(color: Foundation.NSExpression)
  public func changeBackgroundColor(color: UIKit.UIColor)
  public func addLocationSmartLabels(level: MiLevel)
  public func displayOverlays(overlays: [MiOverlay])
  public func removeAllOverlays(level: MiLevel? = nil)
  public func getOverlays(level: MiLevel? = nil) -> [MiOverlay]
  public func removeOverlays(overlays: [MiOverlay])
  @objc deinit
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
}
@_hasMissingDesignatedInitializers open class MiDirections {
  public var path: [MiNode]
  public var instructions: [MiInstruction]
  final public let distance: Swift.Double
  @objc deinit
}
@_hasMissingDesignatedInitializers open class MiFocusPoint {
  @objc deinit
}
@_hasMissingDesignatedInitializers open class MiLayerManager {
  final public let id: Swift.String
  public var smartLabelManager: MiSmartLabelManager?
  public var overlayManager: MiOverlayManager?
  public func setStyles()
  public func enableLayer(layer: Swift.Int, enable: Swift.Bool)
  @objc deinit
}
public enum MiGestureType {
  case PINCH
  case PAN
  public static func == (a: MiGestureType, b: MiGestureType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers open class MiNode : MiNavigable, Swift.Hashable, MiFocusable {
  public var navigatableNodes: [MiNode] {
    get
  }
  final public let id: Swift.String
  final public let externalId: Swift.String?
  final public let weight: Swift.Double
  final public let multiplier: Swift.Double
  final public let accessible: Swift.Bool
  public var pathLinks: [Swift.String] {
    get
  }
  public var lon: Swift.Double {
    get
  }
  public var lat: Swift.Double {
    get
  }
  public var z: Swift.Double {
    get
  }
  final public let levelId: Swift.String
  public var level: MiLevel? {
    get
  }
  public var spaces: [MiSpace] {
    get
  }
  public var locations: [MiLocation] {
    get
  }
  public func getPoints() -> [MiFocusPoint]
  public static func == (lhs: MiNode, rhs: MiNode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  open var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers open class MiCameraManager {
  public func setTilt(tilt: Swift.Double, over: Swift.Double)
  public func disableTilt(over: Swift.Double = 1)
  public func focusOn(focusables: [MiFocusable], heading: Swift.Double? = nil, tilt: Swift.Double? = nil, padding: Swift.Double = 0, over: Swift.Double)
  public func focusOn(focusable: MiFocusable, heading: Swift.Double? = nil, tilt: Swift.Double? = nil, padding: Swift.Double = 0, over: Swift.Double = 0)
  @objc deinit
}
@_hasMissingDesignatedInitializers open class MiPolygonOutlineManager : MiBasePolygonStyleManager {
  @objc deinit
}
public struct MiPicture : Swift.Codable {
  public let original: Swift.String?
  public let xxsmall: Swift.String?
  public let xsmall: Swift.String?
  public let small: Swift.String?
  public let medium: Swift.String?
  public let large: Swift.String?
  public let xlarge: Swift.String?
  public let xxlarge: Swift.String?
  public let dimension66x66: Swift.String?
  public let dimension140x140: Swift.String?
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers open class MiPositionManager {
  public func startTrackingUserPosition(useDefaultLocationEngine: Swift.Bool)
  public func updateUserPosition(point: CoreLocation.CLLocationCoordinate2D, level: Swift.Int?)
  @objc deinit
}
public enum MIGetVenueResultCode {
  case SUCCESS
  case SUCCESS_CACHED
  case FAILED
  case FAILED_TO_CONFIGURE_MVF
  case FAILED_TO_GET_MANIFEST
  case FAILED_TO_DOWNLOAD
  case FAILED_TO_PARSE_FILES
  public static func == (a: MIGetVenueResultCode, b: MIGetVenueResultCode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public typealias DataCompletionHandler = (Foundation.Data?, Foundation.URLResponse?, Swift.Error?) -> Swift.Void
public enum HttpError : Swift.Error {
  case requestError(Swift.Error)
  case missingData
  case requestTimeout
  case invalidJSON(Swift.Error)
  case invalidJSONSchemea
  case httpErrorCode(Swift.Int)
  public var localizedDescription: Swift.String {
    get
  }
}
public struct MiAnalytics {
  public static var deviceData: [Swift.String : Any]
  public static func updateSessionId()
  public static func enteredApp(completionHandler: DataCompletionHandler? = nil)
  public static func exitedApp(completionHandler: DataCompletionHandler? = nil)
  public static func selectedVenue(_ venue: Swift.String, completionHandler: DataCompletionHandler? = nil)
  public static func selectedLocation(_ location: MiLocation, _ venue: Swift.String?, completionHandler: DataCompletionHandler? = nil)
  public static func selectedCategory(_ venue: Swift.String, _ categoryId: Swift.String, completionHandler: DataCompletionHandler? = nil)
  public static func startedWayfindTo(_ location: MiLocation, _ venue: Swift.String?, completionHandler: DataCompletionHandler? = nil) -> MiAnalytics.MiWayfind
  @_hasMissingDesignatedInitializers open class MiWayfind {
    public func successful(completionHandler: DataCompletionHandler? = nil)
    @objc deinit
  }
}
open class MiStyleProperties {
  public init(color: UIKit.UIColor, opacity: Swift.Double)
  @objc deinit
}
@_hasMissingDesignatedInitializers open class MiSmartLabelManager {
  @objc deinit
}
@_hasMissingDesignatedInitializers open class MiConnection {
  final public let originNodeId: Swift.String
  public var destinationNodeIds: [Swift.String] {
    get
  }
  final public let name: Swift.String
  final public let type: Swift.String?
  final public let accessible: Swift.Bool
  final public let weight: Swift.Double
  final public let multiplier: Swift.Double
  @objc deinit
}
@_hasMissingDesignatedInitializers open class MiOverlayManager {
  public func getOverlayFeatures() -> [Mapbox.MGLPointFeature]
  public func displayOverlays(overlays: [MiOverlay])
  public func removeOverlays(overlays: [MiOverlay])
  public func clear()
  public func addLayer()
  public func removeLayer()
  @objc deinit
}
open class MiOutlineProperties : MiStyleProperties {
  public init(color: UIKit.UIColor, width: Swift.Double, opacity: Swift.Double)
  @objc deinit
  override public init(color: UIKit.UIColor, opacity: Swift.Double)
}
@_hasMissingDesignatedInitializers open class MiPathSegment {
  public var level: MiLevel? {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers open class MiLocation : BaseObject, MiNavigable {
  final public let name: Swift.String
  final public let externalId: Swift.String?
  public var navigatableNodes: [MiNode]
  public var spaces: [MiSpace]
  public var categories: [MiCategory]
  final public let logo: MiPicture?
  final public let picture: MiPicture?
  @objc deinit
}
@_inheritsConvenienceInitializers open class MiHighlightProperties : MiStyleProperties {
  @objc deinit
  override public init(color: UIKit.UIColor, opacity: Swift.Double)
}
@_hasMissingDesignatedInitializers open class MiPolygonStyleManager {
  public func setPolygonColor(id: Swift.String, styleProperties: MiHighlightProperties)
  public func setPolygonOutline(id: Swift.String, styleProperties: MiOutlineProperties)
  public func clearAllPolygonStyles()
  public func clearPolygonStyle(id: Swift.String)
  @objc deinit
}
open class MiOverlay {
  final public let id: Swift.String
  final public let coordinates: CoreLocation.CLLocationCoordinate2D
  final public let feature: Mapbox.MGLPointFeature
  final public let image: UIKit.UIImage
  final public let level: MiLevel
  public init(coordinates: CoreLocation.CLLocationCoordinate2D, level: MiLevel, image: UIKit.UIImage)
  convenience public init(coordinates: CoreLocation.CLLocationCoordinate2D, level: MiLevel, view: UIKit.UIView)
  @objc deinit
}
public class MappedIn {
  public init()
  public init(mappedinKey: Swift.String, mappedinSecret: Swift.String, mappedinEndpoint: Swift.String? = nil)
  public func getVenue(venueSlug: Swift.String, enableOfflineSupport: Swift.Bool = true, completionHandler: @escaping (MIGetVenueResultCode, MiVenue?) -> (Swift.Void))
  public func getVenues(completionHandler: @escaping (MIGetVenueResultCode, [(Swift.String, Swift.String)]) -> (Swift.Void))
  @objc deinit
}
@_hasMissingDesignatedInitializers open class MiPolygonHighlightManager : MiBasePolygonStyleManager {
  @objc deinit
}
public protocol MiMapViewDelegate : AnyObject {
  func onTapNothing()
  func didTapSpace(space: MiSpace) -> Swift.Bool
  func onTapCoordinates(point: CoreLocation.CLLocationCoordinate2D)
  func didTapOverlay(overlay: MiOverlay) -> Swift.Bool
  func onLevelChange(level: MiLevel)
  func onManipulateCamera(gesture: MiGestureType)
  func onMapLoaded(status: MiMapStatus)
}
@_hasMissingDesignatedInitializers open class MiSmartLabel {
  final public let level: MiLevel
  final public let text: Swift.String
  final public let point: Mapbox.MGLPointFeature
  final public let id: Swift.String
  @objc deinit
}
public protocol MiFocusable {
  func getPoints() -> [MiFocusPoint]
}
@_hasMissingDesignatedInitializers open class MiLevel : BaseObject, Swift.Hashable, MiFocusable {
  final public let name: Swift.String
  final public let abbreviation: Swift.String
  final public let elevation: Swift.Int
  public var nodes: [Swift.String : MiNode]
  final public let building: Swift.String
  public var connections: [Swift.String : MiConnection] {
    get
  }
  public var locations: [Swift.String : MiLocation] {
    get
  }
  public var spaces: [Swift.String : MiSpace] {
    get
  }
  public var smartLabels: [MiSmartLabel] {
    get
  }
  public func getPoints() -> [MiFocusPoint]
  public static func == (lhs: MiLevel, rhs: MiLevel) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  open var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers open class MiVenue {
  final public let slug: Swift.String
  final public let name: Swift.String
  final public let levels: [MiLevel]
  final public let locations: [MiLocation]
  final public let spaces: [MiSpace]
  final public let categories: [MiCategory]
  @objc deinit
}
@_hasMissingDesignatedInitializers open class BaseObject {
  final public let id: Swift.String
  @objc deinit
}
@_hasMissingDesignatedInitializers open class MiPathManager {
  @objc deinit
}
public protocol MiNavigable {
  var navigatableNodes: [MiNode] { get }
}
extension MiNavigable {
  public var isNavigatable: Swift.Bool {
    get
  }
}
extension MiNavigable {
  public func directions<VenueNavigatable>(activeVenue: MiVenue, to destination: VenueNavigatable, accessible: Swift.Bool = false) -> MiDirections? where VenueNavigatable : MiNavigable
  public func directions<VenueNavigatable>(activeVenue: MiVenue, from origin: VenueNavigatable, accessible: Swift.Bool = false) -> MiDirections? where VenueNavigatable : MiNavigable
}
@_hasMissingDesignatedInitializers open class MiSpace : BaseObject, MiNavigable, Swift.Equatable, MiFocusable {
  public var navigatableNodes: [MiNode] {
    get
  }
  public var level: MiLevel? {
    get
  }
  final public let levelId: Swift.String
  final public let parent: Swift.String?
  final public let externalId: Swift.String?
  final public let layer: Swift.String?
  final public let color: Swift.String?
  final public let height: Swift.Double?
  final public let altitude: Swift.Double?
  public var feature: Mapbox.MGLShape? {
    get
  }
  public var entrances: [MiNode] {
    get
  }
  public var pointNode: MiNode? {
    get
  }
  public var locations: [MiLocation] {
    get
  }
  public func getPoints() -> [MiFocusPoint]
  public static func == (lhs: MiSpace, rhs: MiSpace) -> Swift.Bool
  @objc deinit
}
public typealias MiAction = DirectionsInstructionAction
public struct Departure : MiAction {
}
public struct Arrival : MiAction {
}
public struct Turn : MiAction {
  public enum Bearing {
    case left
    case slightLeft
    case straight
    case slightRight
    case right
    public static func == (a: Turn.Bearing, b: Turn.Bearing) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public let relativeBearing: Turn.Bearing
}
public struct TakeConnection : MiAction {
  public let fromLevel: MiLevel
  public let toLevel: MiLevel
  public let connection: MiConnection
}
public struct ExitConnection : MiAction {
  public let fromLevel: MiLevel
  public let toLevel: MiLevel
  public let connection: MiConnection
}
public protocol DirectionsInstructionAction {
}
@_hasMissingDesignatedInitializers open class MiBasePolygonStyleManager {
  public func stylePolygon(id: Swift.String, styleProperties: MiStyleProperties)
  public func clearAllPolygonStyles()
  public func clearPolygonStyle(id: Swift.String)
  @objc deinit
}
public struct MiInstruction {
  public let node: MiNode
  public let action: MiAction
  public let atLocation: MiLocation?
  public var description: Swift.String {
    get
  }
}
public enum MiMapStatus {
  case loaded
  case error
  public static func == (a: MiMapStatus, b: MiMapStatus) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers open class MiPath : MiFocusable {
  public var segments: [MiPathSegment] {
    get
  }
  public init(pathPoints: [CoreLocation.CLLocationCoordinate2D], pathWidth: Swift.Double, pathColor: UIKit.UIColor, level: MiLevel? = nil)
  public init(path: [MiNode], pathWidth: Swift.Double, pathColor: UIKit.UIColor)
  public func getPoints() -> [MiFocusPoint]
  @objc deinit
}
public struct MiBackgroundStyle {
  public var color: Foundation.NSExpression
}
public struct MiLevelStyle {
  public var fillColor: Foundation.NSExpression
}
public struct MiSpaceStyle {
  public var fillColor: Foundation.NSExpression
  public var fillColorTransition: Mapbox.MGLTransition
  public var fillOpacityTransition: Mapbox.MGLTransition
}
public struct MiSpaceWallStyle {
  public var fillOpacityTransition: Mapbox.MGLTransition
  public var lineWidth: Foundation.NSExpression
  public var lineColor: Foundation.NSExpression
}
public struct MiObstructionStyle {
}
public struct MiObstructionOutlineStyle {
}
public struct MiSpaceOutlineWallStyle {
}
public struct Mi3DStyle {
}
public struct MiLabelsStyle {
}
public struct MiPathStyle {
}
public struct MiLayerStyles {
  public var backgroundStyle: MiBackgroundStyle
  public var levelStyle: MiLevelStyle
  public var spaceStyle: MiSpaceStyle
  public var spaceWallStyle: MiSpaceWallStyle
  public var spaceOutlineStyle: MiSpaceOutlineWallStyle
  public var obstructionStyle: MiObstructionStyle
  public var obstructionOutlineStyle: MiObstructionOutlineStyle
  public var aestheticStyle: MiObstructionStyle
  public var labelsStyle: MiLabelsStyle
  public var level3DStyle: Mi3DStyle
  public var space3DStyle: Mi3DStyle
  public var obstruction3DStyle: Mi3DStyle
  public var aesthetic3DStyle: Mi3DStyle
  public var pathStyle: MiPathStyle
  public init()
}
extension MiGestureType : Swift.Equatable {}
extension MiGestureType : Swift.Hashable {}
extension MIGetVenueResultCode : Swift.Equatable {}
extension MIGetVenueResultCode : Swift.Hashable {}
extension Turn.Bearing : Swift.Equatable {}
extension Turn.Bearing : Swift.Hashable {}
extension MiMapStatus : Swift.Equatable {}
extension MiMapStatus : Swift.Hashable {}
